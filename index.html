<script>
  const gpsCoordinatesDiv = document.getElementById('gps-coordinates');
  const compassNeedle = document.getElementById('compass-needle');

  let lastPosition = { latitude: null, longitude: null };
  const entityPosition = { latitude: 52.158083, longitude: 5.372243 }; // Example target entity coordinates
  const threshold = 0.01; // Threshold for model updates

  // Watch GPS position and update bearing
  if (navigator.geolocation) {
    navigator.geolocation.watchPosition(function(position) {
      const latitude = position.coords.latitude.toFixed(6);
      const longitude = position.coords.longitude.toFixed(6);

      // Always update the compass bearing, ignoring vertical movement
      const bearing = calculateBearing(latitude, longitude, entityPosition.latitude, entityPosition.longitude);

      // Add default 90-degree rotation to the compass
      const adjustedBearing = (bearing + 90) % 360; // Rotate the compass by default 90 degrees
      compassNeedle.style.transform = `rotate(${adjustedBearing}deg)`;

      // Only update the model's position if the change exceeds the threshold
      if (shouldUpdatePosition(latitude, longitude)) {
        lastPosition.latitude = latitude;
        lastPosition.longitude = longitude;

        gpsCoordinatesDiv.innerHTML = `Latitude: ${latitude}<br>Longitude: ${longitude}`;

        // Perform any updates for the model here (for example, changing its visibility or reloading its data)
        // Since the model is jittery, this part will only update when there's a significant change in GPS position.
      }
    }, function(error) {
      gpsCoordinatesDiv.innerHTML = 'Error getting GPS location: ' + error.message;
    }, {
      enableHighAccuracy: true,
      timeout: 20000,
      maximumAge: 0
    });
  } else {
    gpsCoordinatesDiv.innerHTML = 'Geolocation not supported by this browser.';
  }

  // Calculate bearing between two GPS coordinates using the Haversine formula (ignoring vertical movement)
  function calculateBearing(lat1, lon1, lat2, lon2) {
    const toRadians = (deg) => deg * Math.PI / 180;
    const toDegrees = (rad) => rad * 180 / Math.PI;

    const dLon = toRadians(lon2 - lon1);
    const y = Math.sin(dLon) * Math.cos(toRadians(lat2));
    const x = Math.cos(toRadians(lat1)) * Math.sin(toRadians(lat2)) - 
              Math.sin(toRadians(lat1)) * Math.cos(toRadians(lat2)) * Math.cos(dLon);

    let bearing = toDegrees(Math.atan2(y, x));
    bearing = (bearing + 360) % 360; // Normalize to 0-360 degrees

    return bearing;
  }

  // Check if the position change exceeds the threshold for model updates
  function shouldUpdatePosition(lat, lon) {
    if (lastPosition.latitude === null || lastPosition.longitude === null) {
      return true;
    }

    const latDiff = Math.abs(lat - lastPosition.latitude);
    const lonDiff = Math.abs(lon - lastPosition.longitude);

    return latDiff > threshold || lonDiff > threshold;
  }

  // Listen for device orientation to rotate the compass smoothly, with default 90-degree adjustment
  window.addEventListener('deviceorientation', function(event) {
    const alpha = event.alpha; // Alpha represents the rotation around z-axis
    const adjustedAlpha = (alpha + 90) % 360; // Add default 90-degree rotation
    compassNeedle.style.transform = `rotate(${adjustedAlpha}deg)`; // Apply rotation to compass needle
  }, true);
</script>